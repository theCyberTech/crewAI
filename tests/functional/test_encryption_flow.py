import os
import pytest
from unittest.mock import MagicMock

from src.crewai.security.encryption_utils import decrypt
from crewai import Agent, Crew, Task, SecurityConfig
from crewai.tasks.task_output import TaskOutput

# Known output for tasks, to make assertions easier
KNOWN_TASK_OUTPUT_PLAINTEXT = "This is the expected raw output of the task."
CONTEXT_VALUE_PLAINTEXT = "secret_context_value_for_task2"

# --- Reusable Test Components ---

class EchoAgent(Agent):
    """An agent that simply returns a predefined output or echoes its context."""
    def __init__(self, fixed_output=None, echo_context_prefix="", **kwargs):
        super().__init__(**kwargs)
        self.fixed_output = fixed_output
        self.echo_context_prefix = echo_context_prefix
        # Mock the LLM and other complex parts not needed for these tests
        self.llm = MagicMock()
        self.agent_executor = MagicMock()
        # Ensure execute_task is not the default one that tries to call LLM
        self.execute_task = self._mock_execute_task

    def _mock_execute_task(self, task: Task, context: Optional[str] = None, tools: Optional[list] = None) -> str:
        if self.fixed_output:
            return self.fixed_output
        if context:
            return f"{self.echo_context_prefix}{context}"
        return "No specific output or context provided to EchoAgent."

def create_test_crew(encryption_enabled: bool, initial_tasks=None, agents_list=None):
    """Helper function to create a Crew with specified encryption settings."""
    sec_config = SecurityConfig(encrypt_communication=encryption_enabled)
    # encryption_key will be auto-generated by SecurityConfig if encryption_enabled is True and no key is passed

    if agents_list is None:
        # Default agent for simple tasks
        default_agent = EchoAgent(
            role="Test Agent",
            goal="Produce a known output",
            backstory="A simple agent for testing.",
            fixed_output=KNOWN_TASK_OUTPUT_PLAINTEXT,
            verbose=True, # Enable verbose to see logs if needed
            allow_delegation=False
        )
        agents_list = [default_agent]

    # Ensure all agents in the list have their crew and logger set up, as Crew normally does this.
    # This is important because our encryption/decryption logic in Agent/CrewAgentExecutor might use agent.crew.security_config or agent._logger
    # However, for these tests, the crucial part is that the Crew object has the security_config.
    # The agent's own execute_task is mocked, so it won't directly use crew.security_config for decryption (that's tested in Agent.execute_task's direct unit test if we had one for that method).
    # The Crew's _execute_tasks and _process_async_tasks are what use crew.security_config for encryption.

    crew = Crew(
        agents=agents_list,
        tasks=initial_tasks or [],
        security_config=sec_config,
        verbose=True
    )

    # Manually assign crew to agents and tasks if not done automatically or if tasks are added later
    for agent in crew.agents:
        agent.crew = crew
        agent._logger = MagicMock() # Mock logger to avoid issues if verbose is on

    for task in crew.tasks:
        if task.agent: # If task has a specific agent
             task.agent.crew = crew
             task.agent._logger = MagicMock()
        # Assign the first agent from the crew if no specific agent is set for the task and agents_list is provided
        elif crew.agents:
            task.agent = crew.agents[0]
            task.agent.crew = crew
            task.agent._logger = MagicMock()


    return crew

# --- Test Cases ---

def test_task_output_is_encrypted_when_enabled():
    """Test that TaskOutput.raw is encrypted when communication encryption is enabled."""
    task1 = Task(description="Produce known output", expected_output="A simple string.", agent=None) # Agent will be assigned by create_test_crew

    crew = create_test_crew(encryption_enabled=True, initial_tasks=[task1])

    # Assign the default agent to the task if not already assigned
    if not task1.agent and crew.agents:
        task1.agent = crew.agents[0]

    assert crew.security_config.encrypt_communication is True
    assert crew.security_config.encryption_key is not None, "Encryption key should be auto-generated"

    # Mock the agent's execute_task to return a known plaintext
    # The encryption happens in Crew._execute_tasks / _process_async_tasks AFTER agent execution
    original_agent_execute = task1.agent.execute_task
    task1.agent.execute_task = MagicMock(return_value=KNOWN_TASK_OUTPUT_PLAINTEXT)

    crew_output = crew.kickoff()

    task1.agent.execute_task = original_agent_execute # Restore

    assert len(crew_output.tasks_output) == 1
    task_output = crew_output.tasks_output[0]

    assert task_output.raw != KNOWN_TASK_OUTPUT_PLAINTEXT, "Raw output should be encrypted"

    decrypted_output = decrypt(task_output.raw, crew.security_config.encryption_key)
    assert decrypted_output == KNOWN_TASK_OUTPUT_PLAINTEXT, "Decrypted output should match original known output"

def test_task_output_is_not_encrypted_when_disabled():
    """Test that TaskOutput.raw is NOT encrypted when communication encryption is disabled."""
    task1 = Task(description="Produce known output", expected_output="A simple string.", agent=None)
    crew = create_test_crew(encryption_enabled=False, initial_tasks=[task1])

    if not task1.agent and crew.agents:
        task1.agent = crew.agents[0]

    assert crew.security_config.encrypt_communication is False
    assert crew.security_config.encryption_key is None, "Encryption key should not be generated"

    original_agent_execute = task1.agent.execute_task
    task1.agent.execute_task = MagicMock(return_value=KNOWN_TASK_OUTPUT_PLAINTEXT)

    crew_output = crew.kickoff()

    task1.agent.execute_task = original_agent_execute # Restore

    assert len(crew_output.tasks_output) == 1
    task_output = crew_output.tasks_output[0]

    assert task_output.raw == KNOWN_TASK_OUTPUT_PLAINTEXT, "Raw output should be plaintext"

def test_agent_receives_decrypted_context():
    """
    Test that an agent in an encryption-enabled crew receives decrypted context from a previous task.
    Task 1 produces output. Task 2 uses this output as context.
    Task 2's agent (EchoAgent) will return the context it received.
    We then check if Task 2's raw output (after decryption) contains the original plaintext from Task 1.
    """
    agent1 = EchoAgent(role="Context Provider", goal="Provide context", backstory="Provides context.", fixed_output=CONTEXT_VALUE_PLAINTEXT)
    agent2 = EchoAgent(role="Context Consumer", goal="Consume context", backstory="Consumes context.", echo_context_prefix="Processed: ")

    task1 = Task(description="Produce secret context", expected_output="Secret context.", agent=agent1)
    # Task 2's description uses Task 1's output. The 'context' for task2.execute_sync will be task1's output.
    task2 = Task(description="Process context: {{tasks_output[0].description}}", expected_output="Processed context.", agent=agent2, context=[task1])

    crew = create_test_crew(encryption_enabled=True, initial_tasks=[task1, task2], agents_list=[agent1, agent2])

    assert crew.security_config.encrypt_communication is True
    assert crew.security_config.encryption_key is not None

    # No need to mock execute_task for EchoAgent as its behavior is defined.
    # Agent1 will output CONTEXT_VALUE_PLAINTEXT. This will be encrypted into task1.output.raw.
    # Agent2's execute_task should receive the DECRYPTED CONTEXT_VALUE_PLAINTEXT.
    # Agent2 will then return "Processed: CONTEXT_VALUE_PLAINTEXT". This will be encrypted into task2.output.raw.

    crew_output = crew.kickoff()

    assert len(crew_output.tasks_output) == 2
    task1_output = crew_output.tasks_output[0]
    task2_output = crew_output.tasks_output[1]

    # Verify Task 1's output was encrypted
    assert task1_output.raw != CONTEXT_VALUE_PLAINTEXT
    decrypted_task1_raw = decrypt(task1_output.raw, crew.security_config.encryption_key)
    assert decrypted_task1_raw == CONTEXT_VALUE_PLAINTEXT

    # Verify Task 2's output (which is based on the context it received)
    assert task2_output.raw != f"Processed: {CONTEXT_VALUE_PLAINTEXT}"
    decrypted_task2_raw = decrypt(task2_output.raw, crew.security_config.encryption_key)

    # This asserts that Agent2 indeed received the decrypted context from Task1
    assert decrypted_task2_raw == f"Processed: {CONTEXT_VALUE_PLAINTEXT}"


def test_sequential_encryption_decryption_flow():
    """
    Test a sequence of tasks where output of T1 (encrypted) is context for T2 (decrypted by agent),
    and T2's output is then encrypted.
    """
    output_t1_plain = "Initial data from task 1"
    suffix_t2 = " - processed by task 2"

    agent1 = EchoAgent(role="Producer", goal="Produce data", backstory="Produces data.", fixed_output=output_t1_plain)
    agent2 = EchoAgent(role="Processor", goal="Process data", backstory="Processes data.", echo_context_prefix="") # Will just return context + suffix

    # Redefine agent2's execute_task for this specific test to append a suffix
    def agent2_custom_execute(task: Task, context: Optional[str] = None, tools: Optional[list] = None) -> str:
        if context:
            return f"{context}{suffix_t2}"
        return f"No context provided{suffix_t2}"
    agent2.execute_task = agent2_custom_execute


    task1 = Task(description="Generate initial data", expected_output="Initial data", agent=agent1)
    task2 = Task(description="Process data from Task 1", expected_output="Processed data", agent=agent2, context=[task1])

    crew = create_test_crew(encryption_enabled=True, initial_tasks=[task1, task2], agents_list=[agent1, agent2])

    assert crew.security_config.encrypt_communication is True
    key = crew.security_config.encryption_key
    assert key is not None

    crew_output = crew.kickoff()

    assert len(crew_output.tasks_output) == 2
    task1_output_obj = crew_output.tasks_output[0]
    task2_output_obj = crew_output.tasks_output[1]

    # Check Task 1's output
    assert task1_output_obj.raw != output_t1_plain, "T1 raw output should be encrypted"
    decrypted_t1 = decrypt(task1_output_obj.raw, key)
    assert decrypted_t1 == output_t1_plain, "Decrypted T1 output should match original"

    # Check Task 2's output
    expected_t2_plain_output = f"{output_t1_plain}{suffix_t2}"
    assert task2_output_obj.raw != expected_t2_plain_output, "T2 raw output should be encrypted"
    decrypted_t2 = decrypt(task2_output_obj.raw, key)
    assert decrypted_t2 == expected_t2_plain_output, "Decrypted T2 output should reflect processing of decrypted T1 output"

# Test for agent final output being encrypted is implicitly covered by
# test_task_output_is_encrypted_when_enabled, because TaskOutput.raw is derived
# from the agent's final output (which comes from CrewAgentExecutor._invoke_loop).
# If TaskOutput.raw is correctly encrypted, it means the agent's output was encrypted before becoming TaskOutput.raw.

# To run: pytest tests/functional/test_encryption_flow.py
